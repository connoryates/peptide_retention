#
# *** DO NOT EDIT THIS FILE ***
# Generated on Tue Nov  8 01:37:33 2016 UTC, by
#   Mesoderm (0.140780)
#   Moose::Object (2.1806)
#

package Peptide::Schema::_mesoderm;
use Moose::Role;
sub schema { shift->result_source->schema->{__mesoderm} }

package Peptide::Schema::_dbic;
use base qw(DBIx::Class::Schema);

package Peptide::Schema::_scaffold;
use Moose::Role;
require Scalar::Util;
requires 'connect_args';

has 'dbic' => (
  is => 'ro',
  isa => 'Peptide::Schema::_dbic',
  lazy => 1,
  default => sub {
    my $self = shift;
    my $dbic = Peptide::Schema::_dbic->connect( $self->connect_args );
    Scalar::Util::weaken($dbic->{__mesoderm} = $self);
    return $dbic;
  },
);

##
## Table: peptides
##

has 'peptide' => (
  is      => 'ro',
  lazy    => 1,
  isa     => 'Peptide::Schema::ResultSet::Peptide',
  default => sub { shift->dbic->resultset('peptide'); },
);

{
  package Peptide::Schema::Peptide;
  use Moose;
  extends 'DBIx::Class';

  __PACKAGE__->load_components(qw/ Core /);

  with qw(
    Peptide::Schema::_mesoderm
    );
  no Moose;

  __PACKAGE__->table('peptides');
  __PACKAGE__->add_columns(
    id => {
      data_type => 'BIGINT',
      default_value => 'nextval(\'peptides_id_seq\'::regclass)',
      is_nullable => 0,
      size => 0
    },
    sequence => {
      data_type => 'TEXT',
      default_value => undef,
      is_nullable => 0,
      size => 0
    },
    molecular_weight => {
      data_type => 'REAL',
      default_value => undef,
      is_nullable => 1,
      size => 0
    },
    bullbreese => {
      data_type => 'REAL',
      default_value => undef,
      is_nullable => 1,
      size => 0
    },
    real_retention_time => {
      data_type => 'REAL',
      default_value => undef,
      is_nullable => 1,
      size => 0
    },
    length => {
      data_type => 'INTEGER',
      default_value => undef,
      is_nullable => 1,
      size => 0
    },
    cleavage => {
      data_type => 'CHARACTER VARYING(255)',
      default_value => undef,
      is_nullable => 1,
      size => 259
    },
    average_mass => {
      data_type => 'NUMERIC',
      default_value => undef,
      is_nullable => 1,
      size => 0
    },
    monoisotopic_mass => {
      data_type => 'NUMERIC',
      default_value => undef,
      is_nullable => 1,
      size => 0
    },
  );
  __PACKAGE__->has_many( predictions => 'Peptide::Schema::Prediction',{
    'foreign.peptide_id' => 'self.id'
  });
  __PACKAGE__->has_many( proteins => 'Peptide::Schema::Protein',{
    'foreign.peptide_id' => 'self.id'
  });
  __PACKAGE__->many_to_many( 'peptides' => qw[ predictions peptides ]);
  __PACKAGE__->many_to_many( 'protein_sequences' => qw[ proteins protein_sequences ]);
  { package Peptide::Schema::ResultSet::Peptide;
    use Moose;
    extends 'DBIx::Class::ResultSet';
    with qw(
      Peptide::Schema::_mesoderm
      );
    no Moose;
  }
  __PACKAGE__->set_primary_key('id');
  __PACKAGE__->resultset_class('Peptide::Schema::ResultSet::Peptide');
  Peptide::Schema::_dbic->register_class( peptide => __PACKAGE__ );
}

##
## Table: predictions
##

has 'prediction' => (
  is      => 'ro',
  lazy    => 1,
  isa     => 'Peptide::Schema::ResultSet::Prediction',
  default => sub { shift->dbic->resultset('prediction'); },
);

{
  package Peptide::Schema::Prediction;
  use Moose;
  extends 'DBIx::Class';

  __PACKAGE__->load_components(qw/ Core /);

  with qw(
    Peptide::Schema::_mesoderm
    );
  no Moose;

  __PACKAGE__->table('predictions');
  __PACKAGE__->add_columns(
    id => {
      data_type => 'BIGINT',
      default_value => 'nextval(\'predictions_id_seq\'::regclass)',
      is_nullable => 0,
      size => 0
    },
    algorithm => {
      data_type => 'CHARACTER VARYING(255)',
      default_value => undef,
      is_nullable => 0,
      size => 259
    },
    predicted_time => {
      data_type => 'REAL',
      default_value => undef,
      is_nullable => 1,
      size => 0
    },
    peptide_id => {
      data_type => 'BIGINT',
      default_value => 'nextval(\'predictions_peptide_id_seq\'::regclass)',
      is_nullable => 0,
      size => 0
    },
  );
  __PACKAGE__->has_many( peptides => 'Peptide::Schema::Peptide',{
    'foreign.id' => 'self.peptide_id'
  });
  { package Peptide::Schema::ResultSet::Prediction;
    use Moose;
    extends 'DBIx::Class::ResultSet';
    with qw(
      Peptide::Schema::_mesoderm
      );
    no Moose;
  }
  __PACKAGE__->set_primary_key('id');
  __PACKAGE__->resultset_class('Peptide::Schema::ResultSet::Prediction');
  Peptide::Schema::_dbic->register_class( prediction => __PACKAGE__ );
}

##
## Table: protein_descriptions
##

has 'protein_description' => (
  is      => 'ro',
  lazy    => 1,
  isa     => 'Peptide::Schema::ResultSet::ProteinDescription',
  default => sub { shift->dbic->resultset('protein_description'); },
);

{
  package Peptide::Schema::ProteinDescription;
  use Moose;
  extends 'DBIx::Class';

  __PACKAGE__->load_components(qw/ Core /);

  with qw(
    Peptide::Schema::_mesoderm
    );
  no Moose;

  __PACKAGE__->table('protein_descriptions');
  __PACKAGE__->add_columns(
    id => {
      data_type => 'BIGINT',
      default_value => 'nextval(\'protein_descriptions_id_seq\'::regclass)',
      is_nullable => 0,
      size => 0
    },
    primary_id => {
      data_type => 'CHARACTER VARYING(255)',
      default_value => undef,
      is_nullable => 0,
      size => 259
    },
    description => {
      data_type => 'TEXT',
      default_value => undef,
      is_nullable => 1,
      size => 0
    },
  );
  __PACKAGE__->has_many( protein_sequences => 'Peptide::Schema::ProteinSequence',{
    'foreign.primary_id' => 'self.primary_id'
  });
  __PACKAGE__->many_to_many( 'proteins' => qw[ protein_sequences proteins ]);
  { package Peptide::Schema::ResultSet::ProteinDescription;
    use Moose;
    extends 'DBIx::Class::ResultSet';
    with qw(
      Peptide::Schema::_mesoderm
      );
    no Moose;
  }
  __PACKAGE__->set_primary_key('id');
  __PACKAGE__->resultset_class('Peptide::Schema::ResultSet::ProteinDescription');
  Peptide::Schema::_dbic->register_class( protein_description => __PACKAGE__ );
}

##
## Table: protein_sequences
##

has 'protein_sequence' => (
  is      => 'ro',
  lazy    => 1,
  isa     => 'Peptide::Schema::ResultSet::ProteinSequence',
  default => sub { shift->dbic->resultset('protein_sequence'); },
);

{
  package Peptide::Schema::ProteinSequence;
  use Moose;
  extends 'DBIx::Class';

  __PACKAGE__->load_components(qw/ Core /);

  with qw(
    Peptide::Schema::_mesoderm
    );
  no Moose;

  __PACKAGE__->table('protein_sequences');
  __PACKAGE__->add_columns(
    id => {
      data_type => 'BIGINT',
      default_value => 'nextval(\'protein_sequences_id_seq\'::regclass)',
      is_nullable => 0,
      size => 0
    },
    sequence => {
      data_type => 'TEXT',
      default_value => undef,
      is_nullable => 0,
      size => 0
    },
    primary_id => {
      data_type => 'CHARACTER VARYING(255)',
      default_value => undef,
      is_nullable => 0,
      size => 259
    },
    average_mass => {
      data_type => 'NUMERIC',
      default_value => undef,
      is_nullable => 1,
      size => 0
    },
    monoisotopic_mass => {
      data_type => 'NUMERIC',
      default_value => undef,
      is_nullable => 1,
      size => 0
    },
  );
  __PACKAGE__->has_many( protein_descriptions => 'Peptide::Schema::ProteinDescription',{
    'foreign.primary_id' => 'self.primary_id'
  });
  __PACKAGE__->has_many( proteins => 'Peptide::Schema::Protein',{
    'foreign.sequence_id' => 'self.id'
  });
  __PACKAGE__->many_to_many( 'peptides' => qw[ proteins peptides ]);
  { package Peptide::Schema::ResultSet::ProteinSequence;
    use Moose;
    extends 'DBIx::Class::ResultSet';
    with qw(
      Peptide::Schema::_mesoderm
      );
    no Moose;
  }
  __PACKAGE__->set_primary_key('id');
  __PACKAGE__->resultset_class('Peptide::Schema::ResultSet::ProteinSequence');
  Peptide::Schema::_dbic->register_class( protein_sequence => __PACKAGE__ );
}

##
## Table: proteins
##

has 'protein' => (
  is      => 'ro',
  lazy    => 1,
  isa     => 'Peptide::Schema::ResultSet::Protein',
  default => sub { shift->dbic->resultset('protein'); },
);

{
  package Peptide::Schema::Protein;
  use Moose;
  extends 'DBIx::Class';

  __PACKAGE__->load_components(qw/ Core /);

  with qw(
    Peptide::Schema::_mesoderm
    );
  no Moose;

  __PACKAGE__->table('proteins');
  __PACKAGE__->add_columns(
    id => {
      data_type => 'BIGINT',
      default_value => 'nextval(\'proteins_id_seq\'::regclass)',
      is_nullable => 0,
      size => 0
    },
    peptide_id => {
      data_type => 'BIGINT',
      default_value => 'nextval(\'proteins_peptide_id_seq\'::regclass)',
      is_nullable => 0,
      size => 0
    },
    sequence_id => {
      data_type => 'BIGINT',
      default_value => 'nextval(\'proteins_sequence_id_seq\'::regclass)',
      is_nullable => 0,
      size => 0
    },
  );
  __PACKAGE__->has_many( peptides => 'Peptide::Schema::Peptide',{
    'foreign.id' => 'self.peptide_id'
  });
  __PACKAGE__->has_many( protein_sequences => 'Peptide::Schema::ProteinSequence',{
    'foreign.id' => 'self.sequence_id'
  });
  __PACKAGE__->many_to_many( 'protein_descriptions' => qw[ protein_sequences protein_descriptions ]);
  { package Peptide::Schema::ResultSet::Protein;
    use Moose;
    extends 'DBIx::Class::ResultSet';
    with qw(
      Peptide::Schema::_mesoderm
      );
    no Moose;
  }
  __PACKAGE__->set_primary_key('id');
  __PACKAGE__->resultset_class('Peptide::Schema::ResultSet::Protein');
  Peptide::Schema::_dbic->register_class( protein => __PACKAGE__ );
}


1;
